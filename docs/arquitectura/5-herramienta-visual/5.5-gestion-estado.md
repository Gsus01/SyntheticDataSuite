# 5.5. Gestión de Estado

## Enfoque Adoptado

El prototipo utiliza **React Hooks** como mecanismo principal de gestión de estado, sin introducir librerías adicionales como Redux o Zustand. Esta decisión responde al tamaño del proyecto y a la naturaleza contenida del estado: toda la lógica relevante reside en un único componente principal (`FlowEditor`), lo que hace innecesario un sistema de estado global.

React Flow, la librería de visualización utilizada, proporciona sus propios hooks (`useNodesState`, `useEdgesState`) que gestionan internamente el estado del grafo y exponen funciones para modificarlo. El componente `FlowEditor` simplemente consume estos hooks y añade estado adicional para aspectos como la compilación, la ejecución y la persistencia.

---

## Estado del Editor

El componente `FlowEditor` mantiene múltiples piezas de estado mediante `useState`:

**Estado del grafo** (gestionado por React Flow):
- `nodes`: lista de nodos con sus posiciones y datos.
- `edges`: lista de aristas con sus conexiones.

**Estado de sesión**:
- `sessionId`: identificador único de la sesión de edición actual.
- `selectedNodeId`: nodo actualmente seleccionado en el canvas.

**Estado de compilación**:
- `compiledState`: manifiesto YAML generado, si existe.
- `isCompileDirty`: indica si el grafo ha cambiado desde la última compilación.

**Estado de ejecución**:
- `submitResult`: resultado del envío a Argo (nombre del workflow, namespace).
- `submitting`: indica si hay un envío en curso.

**Estado de persistencia**:
- `activeWorkflow`: workflow cargado desde almacenamiento, si existe.
- `hasUnsavedChanges`: indica si hay modificaciones sin guardar.

---

## Flujo de Datos

El estado fluye de forma unidireccional, siguiendo el modelo estándar de React. Cuando el usuario interactúa con el canvas (arrastra un nodo, crea una conexión), React Flow actualiza el estado interno y dispara los callbacks correspondientes. El componente `FlowEditor` reacciona a estos cambios mediante funciones como `onNodesChange` y `onEdgesChange`, que además marcan el estado como "dirty" para indicar que se requiere recompilación.

Los componentes hijos (`Sidebar`, `NodeInspector`, `WorkflowTerminal`) reciben datos y callbacks como props, sin acceso directo al estado. Esto mantiene un flujo de datos predecible y facilita el debugging.

---

## Alternativas Consideradas

**Redux** habría proporcionado un store centralizado con time-travel debugging, pero introduce boilerplate significativo que no se justifica para un único componente con estado localizado.

**Context API** es una opción intermedia que evitaría el prop drilling, pero el árbol de componentes del editor es suficientemente plano como para no requerirlo.

**Zustand** ofrece una API más simple que Redux, pero de nuevo, la complejidad del estado actual no justifica añadir una dependencia adicional.

Para un prototipo de validación técnica, el enfoque de hooks locales es el más directo y mantenible.

---

## Evolución Futura

Si la aplicación creciera en complejidad (múltiples páginas, estado compartido entre vistas, autenticación), sería razonable migrar a una solución de estado global. En ese escenario, **Zustand** sería una elección apropiada por su simplicidad y buen rendimiento, reservando Redux solo si se requirieran sus capacidades avanzadas de middleware y devtools.
