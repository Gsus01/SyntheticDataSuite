# 5.2. Arquitectura del Frontend

## Introducción

Este apartado describe la arquitectura técnica del frontend de la herramienta visual. Se justifican las decisiones tecnológicas adoptadas, analizando las alternativas consideradas y los criterios que llevaron a cada elección.

El stack tecnológico definido a nivel de arquitectura ha sido validado mediante el prototipo funcional, demostrando su viabilidad para los requisitos identificados.

---

## Stack Tecnológico

| Capa | Tecnología | Versión (Prototipo) |
|:-----|:-----------|:--------------------|
| **Framework** | Next.js | 15.x |
| **UI Library** | React | 19.x |
| **Visualización de grafos** | React Flow | 11.x |
| **Estilos** | Tailwind CSS | 4.x |
| **Lenguaje** | TypeScript | 5.x |
| **Bundler** | Turbopack (Next.js) | — |

---

## Framework: Next.js

### Justificación de la Elección

Next.js se selecciona como framework principal por las siguientes razones:

| Criterio | Valoración |
|:---------|:-----------|
| **Renderizado híbrido** | Permite SSR (Server-Side Rendering), SSG (Static Site Generation) y CSR (Client-Side Rendering) según las necesidades de cada página |
| **Estructura de proyecto** | Convenciones claras (App Router) que facilitan la organización del código |
| **Optimización de producción** | Bundling, code splitting y optimización de imágenes integrados |
| **Ecosistema React** | Compatibilidad total con el ecosistema de componentes React |
| **Developer Experience** | Hot reload rápido, tipado con TypeScript integrado |

### Alternativas Consideradas

| Alternativa | Motivo de Descarte |
|:------------|:-------------------|
| **Create React App (CRA)** | Proyecto oficialmente deprecado. No ofrece SSR ni optimizaciones de producción avanzadas. |
| **Vite + React** | Excelente para SPAs, pero requiere configuración adicional para SSR y carece de las convenciones de estructura de Next.js. |
| **Vue.js / Nuxt** | Ecosistema sólido, pero menor disponibilidad de librerías de visualización de grafos maduras comparado con React. |
| **Angular** | Mayor curva de aprendizaje, arquitectura más rígida. Menos adecuado para prototipos que requieren iteración rápida. |

### Consideraciones de Uso

En el prototipo actual, el frontend opera principalmente como **SPA (Single Page Application)** con renderizado del lado del cliente. Las capacidades de SSR de Next.js no se explotan intensivamente en esta fase, pero la arquitectura permite aprovecharlas en el futuro para:

- Páginas de landing o documentación con mejor SEO.
- Pre-renderizado de dashboards con datos estáticos.
- Generación de vistas compartibles de workflows.

---

## Librería de UI: React

### Justificación de la Elección

React se adopta como librería de construcción de interfaces por su posición dominante en el ecosistema frontend y su modelo de componentes declarativos.

| Criterio | Valoración |
|:---------|:-----------|
| **Modelo de componentes** | Componentes reutilizables con estado local y props |
| **Ecosistema** | La librería con mayor número de componentes de terceros disponibles |
| **Compatibilidad con React Flow** | React Flow está construido específicamente para React |
| **Comunidad y soporte** | Amplia documentación, tutoriales y recursos de aprendizaje |
| **Talento disponible** | Alta probabilidad de encontrar desarrolladores con experiencia en React |

### Alternativas Consideradas

| Alternativa | Motivo de Descarte |
|:------------|:-------------------|
| **Vue.js** | Excelente alternativa, pero las librerías de visualización de grafos (como Vue Flow) son menos maduras que sus equivalentes en React. |
| **Svelte** | Rendimiento excelente, pero ecosistema más reducido y menor disponibilidad de librerías especializadas. |
| **Solid.js** | Prometedor rendimiento, pero ecosistema muy joven para un proyecto de esta complejidad. |

---

## Visualización de Grafos: React Flow

### Justificación de la Elección

React Flow es la pieza central de la herramienta visual. Proporciona un canvas interactivo para dibujar grafos dirigidos, que es exactamente lo que se necesita para representar flujos de trabajo (DAGs).

| Criterio | Valoración |
|:---------|:-----------|
| **Especialización** | Diseñada específicamente para editores de nodos y flujos |
| **Interactividad** | Drag & drop, conexión de nodos, zoom, pan, selección múltiple |
| **Extensibilidad** | Nodos y aristas personalizables mediante componentes React |
| **Rendimiento** | Virtualización para manejar grafos con muchos nodos |
| **Comunidad activa** | Desarrollo continuo, buena documentación, ejemplos abundantes |
| **Licencia** | MIT (uso libre en proyectos comerciales y de código abierto) |

### Alternativas Consideradas

| Alternativa | Motivo de Descarte |
|:------------|:-------------------|
| **GoJS** | Muy potente y madura, pero licencia comercial costosa. No viable para un proyecto de investigación/prototipo. |
| **JointJS / Rappid** | Similar a GoJS: versión gratuita limitada, versión completa de pago. |
| **D3.js** | Librería de bajo nivel para visualización de datos. Requeriría implementar desde cero toda la interactividad (drag, drop, conexiones). Alto esfuerzo de desarrollo. |
| **Cytoscape.js** | Orientada a visualización de grafos estáticos (análisis de redes). Menos enfocada en edición interactiva. |
| **mxGraph / draw.io** | Potente pero con API compleja y documentación dispersa. |
| **Rete.js** | Alternativa viable, pero comunidad y documentación más reducidas que React Flow. |

### Características Utilizadas de React Flow

El prototipo aprovecha las siguientes capacidades de la librería:

- **Nodos personalizados**: Cada tipo de nodo (input, default, output) tiene su propio componente visual con estilos diferenciados.
- **Puertos de conexión (handles)**: Definición de puntos de entrada y salida para artefactos.
- **Aristas con marcadores**: Flechas direccionales que indican el flujo de datos.
- **Eventos de selección**: Detección de nodo seleccionado para mostrar el panel de inspección.
- **Estado de nodos y aristas**: Integración con el estado de React para reflejar cambios en tiempo real.

---

## Estilos: Tailwind CSS

### Justificación de la Elección

Tailwind CSS se adopta como framework de estilos por su enfoque utility-first, que acelera el desarrollo de interfaces sin necesidad de escribir CSS personalizado.

| Criterio | Valoración |
|:---------|:-----------|
| **Velocidad de desarrollo** | Clases utilitarias permiten prototipar rápidamente |
| **Consistencia** | Sistema de diseño predefinido (espaciado, colores, tipografía) |
| **Tamaño en producción** | Purge automático de clases no utilizadas |
| **Integración con React** | Funciona directamente con className |
| **Personalización** | Extensible mediante configuración |

### Alternativas Consideradas

| Alternativa | Motivo de Descarte |
|:------------|:-------------------|
| **CSS Modules** | Requiere más código para lograr los mismos resultados. Menor velocidad de prototipado. |
| **Styled Components** | CSS-in-JS añade overhead de runtime. Menos familiar para desarrolladores acostumbrados a CSS tradicional. |
| **Bootstrap** | Componentes predefinidos útiles, pero estética menos moderna y mayor dificultad para personalizar. |
| **Material UI** | Excelente librería de componentes, pero impone una estética específica (Material Design) que puede no encajar con todos los diseños. |

---

## Lenguaje: TypeScript

### Justificación de la Elección

TypeScript se adopta sobre JavaScript por las garantías de seguridad de tipos que proporciona.

| Criterio | Valoración |
|:---------|:-----------|
| **Detección de errores** | Errores de tipos detectados en tiempo de compilación |
| **Autocompletado** | IDEs pueden inferir tipos y sugerir propiedades/métodos |
| **Refactoring seguro** | Renombrar variables o cambiar firmas de funciones con confianza |
| **Documentación implícita** | Los tipos sirven como documentación del contrato de cada función |
| **Ecosistema** | Tipos disponibles para la mayoría de librerías populares (@types/*) |

En un proyecto con estructuras de datos complejas (grafos, nodos con metadatos, artefactos), TypeScript reduce significativamente la probabilidad de errores en runtime.

---

## Diagrama de Componentes del Frontend

![Frontend Components](diagrams/5.2-frontend-components.puml)

---

## Estructura de Capas

El frontend se organiza en las siguientes capas lógicas:

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentación                           │
│  (Componentes React: FlowEditor, Sidebar, NodeInspector)    │
├─────────────────────────────────────────────────────────────┤
│                    Lógica de Negocio                        │
│  (Hooks, gestión de estado, validaciones)                   │
├─────────────────────────────────────────────────────────────┤
│                    Comunicación                             │
│  (API client: fetch → Backend REST)                         │
├─────────────────────────────────────────────────────────────┤
│                       Tipos                                 │
│  (TypeScript interfaces: FlowNodeData, WorkflowRecord)      │
└─────────────────────────────────────────────────────────────┘
```

---

## Validación Mediante el Prototipo

El stack tecnológico descrito no es una propuesta teórica: ha sido implementado y validado en el prototipo funcional de laboratorio. El prototipo demuestra que:

1. **Next.js + React** proporcionan una base sólida para aplicaciones interactivas de página única.
2. **React Flow** es capaz de manejar flujos de trabajo complejos con múltiples nodos y conexiones.
3. **TypeScript** reduce errores en estructuras de datos anidadas (grafos, configuraciones de nodos).
4. **Tailwind CSS** permite iterar rápidamente en el diseño visual.

La combinación de estas tecnologías ha demostrado ser productiva para el desarrollo y mantenible para futuras extensiones.

---

## Consideraciones para Producción

En la evolución hacia un entorno de producción, se recomendarían las siguientes mejoras:

| Área | Recomendación |
|:-----|:--------------|
| **Testing** | Suite de tests con Jest + React Testing Library |
| **Storybook** | Catálogo de componentes aislados para desarrollo y documentación |
| **Gestión de estado global** | Evaluar Zustand o Redux Toolkit si la complejidad del estado crece |
| **Internacionalización** | next-intl o react-i18next para soporte multi-idioma |
| **Accesibilidad** | Auditoría con herramientas como axe-core |
| **Monitorización** | Integración con Sentry para captura de errores en producción |
