# 5.4. Lógica de Ejecución (El Motor)

## Introducción

El motor de ejecución es el componente del backend responsable de traducir el grafo visual dibujado por el usuario en un manifiesto ejecutable de Argo Workflows. Este proceso implica interpretar la estructura del grafo, validar su coherencia como DAG (Directed Acyclic Graph), resolver las dependencias entre nodos y generar el documento YAML que Argo puede ejecutar.

Este apartado describe cómo funciona ese proceso de interpretación, qué validaciones se aplican y cómo se resuelven las conexiones entre artefactos.

---

## Del Canvas al Manifiesto

Cuando el usuario hace clic en "Compilar" o "Ejecutar", el frontend envía al backend un payload JSON que contiene la lista de nodos y aristas del canvas. El backend procesa este payload en varias fases secuenciales.

### Fase 1: Parsing y Validación Estructural

El backend recibe el payload y lo valida mediante modelos Pydantic. En esta fase se comprueba que cada nodo tenga un identificador único, especifique un `templateName` válido y, en el caso de nodos de entrada, tenga asociado un artefacto subido.

Si algún nodo referencia un template inexistente en el catálogo, el proceso se interrumpe con un error descriptivo. Esta validación temprana evita que errores de configuración lleguen a fases posteriores.

### Fase 2: Construcción del Plan de Nodos

Para cada nodo del grafo, el motor construye un `NodePlan` que contiene:

- El **slug** identificador del nodo (derivado del nombre del template).
- La referencia al **template** del catálogo, con sus artefactos de entrada y salida.
- Los **paths de salida** donde el nodo escribirá sus artefactos en S3.
- Los **parámetros de configuración** fusionados (valores por defecto + modificaciones del usuario).

Los nodos de tipo "input" reciben un tratamiento especial: su "salida" es simplemente el artefacto que el usuario subió previamente. Los nodos de tipo "output" son terminales y no ejecutan lógica de contenedor.

### Fase 3: Resolución de Dependencias

Las aristas del grafo determinan qué nodos dependen de cuáles. El motor recorre todas las conexiones y, para cada arista que va del nodo A al nodo B, registra que B depende de A.

Esta información se traduce directamente en el campo `dependencies` de cada tarea del manifiesto de Argo, que es el mecanismo que utiliza Argo para orquestar el orden de ejecución.

### Fase 4: Binding de Artefactos

Cada arista no solo define una dependencia temporal, sino también un flujo de datos: la salida de un nodo alimenta la entrada de otro. El motor resuelve estas correspondencias siguiendo un algoritmo de matching:

1. Si la arista especifica handles explícitos (`sourceHandle`, `targetHandle`), se respetan.
2. Si coinciden los nombres de salida y entrada (ej. `processed-data` → `processed-data`), se vinculan.
3. En caso contrario, se asignan por orden posicional.

El resultado es un conjunto de `ArtifactBinding` que indica exactamente qué fichero S3 debe montarse en qué path del contenedor destino.

### Fase 5: Generación del Manifiesto YAML

Con toda la información recopilada, el motor genera el documento YAML de Argo. El manifiesto contiene:

- Metadatos del workflow (nombre, namespace).
- Parámetros globales de entrada (artefactos subidos, configuraciones).
- Definición del DAG con cada tarea, sus dependencias y arguments.
- Referencias a los templates de ejecución (WorkflowTemplates de Argo).

El manifiesto se guarda en MinIO y se devuelve al frontend para inspección o ejecución.

![Compilation Flow](diagrams/5.4-compilation-flow.puml)

---

## Validación del Grafo como DAG

Un requisito fundamental es que el grafo sea un DAG válido: dirigido y sin ciclos. Si existiera un ciclo, no habría un orden posible de ejecución.

### Detección de Ciclos

El algoritmo utilizado es una variante de DFS (Depth-First Search) con detección de back-edges. El proceso mantiene dos conjuntos: nodos visitados y nodos en la pila de recursión actual. Si durante el recorrido se encuentra un nodo que ya está en la pila, significa que existe un ciclo.

En el prototipo actual, esta validación ocurre implícitamente durante la resolución de dependencias: si Argo recibe un manifiesto con ciclos, rechazará la ejecución. Sin embargo, para una mejor experiencia de usuario, la arquitectura objetivo debería validar los ciclos en el frontend antes de enviar al backend.

### Nodos Huérfanos

Un nodo huérfano es aquel que no tiene conexiones de entrada ni de salida. Estos nodos no participan en el flujo de datos y, aunque técnicamente pueden ejecutarse, suelen indicar un error del usuario.

El motor actual permite nodos huérfanos, pero los ignora en la generación: solo genera tareas para nodos que forman parte del grafo conectado. En la arquitectura objetivo, el frontend podría advertir visualmente sobre nodos sin conexiones antes de compilar.

### Nodos sin Datos de Entrada

Un caso especial son los nodos (que no son de tipo input) que no tienen ninguna arista entrante. Si un nodo de procesamiento no recibe datos de ningún otro nodo, la ejecución fallará por falta de artefactos de entrada.

El motor valida esta situación y genera un error si detecta que un binding requerido no puede resolverse.

---

## Recorrido del Grafo

El motor no necesita implementar un recorrido topológico explícito porque Argo Workflows se encarga de ello. Al declarar las dependencias entre tareas en el bloque `dag.tasks`, Argo determina automáticamente el orden de ejecución que respeta todas las dependencias.

El motor se limita a traducir fielmente la estructura del grafo visual a la estructura de dependencias que Argo espera. La lógica de scheduling, paralelización y manejo de fallos queda delegada al orquestador.

---

## Manejo de Errores

Durante el proceso de compilación pueden producirse varios tipos de errores, que el motor reporta de forma específica:

**Template no encontrado**: el nodo referencia un `templateName` que no existe en el catálogo. Esto ocurre si el catálogo se actualizó y eliminó un template que el usuario había utilizado.

**Artefacto de entrada faltante**: un nodo de tipo input no tiene asociado un fichero subido. El usuario olvidó subir el dataset antes de ejecutar.

**Binding no resuelto**: una arista conecta nodos cuyos puertos no son compatibles. Por ejemplo, el nodo origen no produce ninguna salida que coincida con las entradas del nodo destino.

En todos los casos, el error se propaga al frontend con un mensaje comprensible que permite al usuario corregir el problema.

---

## Resumen del Proceso

El motor transforma el grafo visual en un manifiesto ejecutable siguiendo un pipeline bien definido: primero valida la estructura, luego construye un plan interno de cada nodo, resuelve las dependencias y bindings entre artefactos, y finalmente genera el YAML de Argo. Las validaciones de coherencia (ciclos, nodos sin entrada) garantizan que solo se ejecuten workflows viables.
