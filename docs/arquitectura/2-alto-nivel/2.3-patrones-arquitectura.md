# 2.3 Patrones de Arquitectura

## Introducción

Este apartado describe los patrones arquitectónicos empleados en la plataforma, explicando las decisiones de diseño tomadas y sus implicaciones. El objetivo es documentar no solo qué patrones se utilizan, sino también por qué se eligieron frente a otras alternativas.

---

## Patrón Principal: DAG Workflow (Grafo Acíclico Dirigido)

El núcleo de la arquitectura de ejecución se basa en el patrón **DAG Workflow**, donde las tareas se modelan como nodos de un grafo y las dependencias como aristas dirigidas.

### Características

- **Sin ciclos**: El grafo debe ser acíclico para garantizar que la ejecución termine
- **Dependencias explícitas**: Cada tarea declara de qué tareas previas depende
- **Paralelización automática**: Tareas sin dependencias mutuas pueden ejecutarse en paralelo

### Ejemplo Visual

El usuario diseña un flujo como:

```
[Input Data] → [Preprocessing] → [Training] → [Generation] → [Output]
```

Internamente, esto se traduce a un DAG donde:
- `Preprocessing` depende de `Input Data`
- `Training` depende de `Preprocessing`
- `Generation` depende de `Training`

### Implementación en Argo Workflows

Argo utiliza la sección `dag.tasks` con el campo `dependencies` para expresar estas relaciones:

```yaml
dag:
  tasks:
  - name: preprocessing
    template: preprocessing
  - name: train-model
    dependencies: [preprocessing]  # Espera a preprocessing
    template: train-model
  - name: generate-data
    dependencies: [train-model]    # Espera a train-model
    template: generate-data
```

---

## Patrón de Comunicación: Artifact Passing via S3

Los contenedores del workflow **no se comunican directamente entre sí**. En su lugar, utilizan un almacenamiento compartido (MinIO/S3) como intermediario.

![Artifact Passing Pattern](diagrams/2.3-artifact-passing-pattern.puml)

### Cómo Funciona

1. **Paso N** escribe su salida en una ruta de S3 (ej: `/outputs/processed_data.csv`)
2. **Argo** detecta que el paso ha terminado exitosamente
3. **Paso N+1** se inicia y recibe el artefacto montado como fichero local
4. El proceso se repite hasta completar el workflow

### Configuración en los Templates

Cada template de Argo define sus entradas y salidas:

```yaml
inputs:
  artifacts:
  - name: processed-data
    path: /tmp/input/data.csv     # Dónde se monta dentro del contenedor

outputs:
  artifacts:
  - name: trained-model
    path: /tmp/output/model.pkl   # Qué fichero se sube a S3
```

### Ventajas de Este Patrón

| Ventaja | Descripción |
|---------|-------------|
| **Desacoplamiento** | Los contenedores no necesitan conocerse; solo acceden a ficheros |
| **Tolerancia a fallos** | Si un paso falla, los artefactos previos persisten y se puede reintentar |
| **Trazabilidad** | Todos los artefactos intermedios quedan almacenados para auditoría |
| **Flexibilidad** | Se pueden añadir nuevos pasos sin modificar los existentes |

### Desventajas y Consideraciones

| Desventaja | Mitigación |
|------------|------------|
| Latencia adicional por I/O a S3 | Aceptable para procesos batch; no apto para tiempo real |
| Coste de almacenamiento | Políticas de retención para limpiar artefactos antiguos |
| Dependencia de MinIO/S3 | Componente crítico; requiere alta disponibilidad en producción |

---

## Modelo de Orquestación: Centralizado

La plataforma utiliza un modelo de **orquestación centralizada** donde Argo Workflows actúa como coordinador único.

### Orquestación vs Coreografía

| Aspecto | Orquestación (usado) | Coreografía (alternativa) |
|---------|---------------------|---------------------------|
| **Control** | Un orquestador central decide qué ejecutar | Cada servicio decide cuándo actuar |
| **Comunicación** | El orquestador invoca servicios | Servicios se comunican via eventos |
| **Visibilidad** | Flujo completo visible en un punto | Flujo distribuido, más difícil de trazar |
| **Acoplamiento** | Servicios desacoplados entre sí | Servicios acoplados a eventos |

### Por Qué Orquestación

La decisión de usar orquestación centralizada se basa en:

1. **Visibilidad del flujo completo**: Argo proporciona una UI donde se ve el estado de cada paso
2. **Control de dependencias**: El DAG se define explícitamente, no emerge de eventos
3. **Simplicidad operativa**: Un único punto de control para monitorizar y depurar
4. **Reintentos granulares**: Se puede reintentar un paso específico sin afectar otros

---

## Patrones No Utilizados

La arquitectura actual no incorpora Event-Driven Architecture (EDA), microservicios tradicionales ni coreografía, y esta decisión es intencional. Los contenedores que ejecutan los pasos del workflow son **efímeros**: se crean para procesar una tarea y se destruyen al terminar, lo que difiere del modelo de microservicios donde los servicios son permanentes y exponen APIs estables. No se requiere comunicación asíncrona mediante colas de mensajes (RabbitMQ, Kafka) porque el flujo de datos ya está gestionado de forma robusta mediante artefactos en S3, y Argo proporciona nativamente la gestión de orden, reintentos y paralelización.

Esta simplificación reduce la complejidad operativa: no hay que mantener brokers de mensajes, no hay problemas de ordenación de eventos ni dead-letter queues que monitorizar. Para el caso de uso de workflows batch —donde la latencia de segundos es aceptable— el patrón de artifact passing cubre las necesidades sin añadir infraestructura adicional.

Si en el futuro la plataforma requiriera **procesamiento en tiempo real** o **reacción a eventos externos**, sería razonable introducir un bus de eventos. Pero para el alcance actual del prototipo, el modelo basado en DAG + S3 ofrece un equilibrio adecuado entre funcionalidad y simplicidad.

---

## Resumen de Decisiones Arquitectónicas

| Decisión | Patrón Elegido | Alternativa Descartada | Motivo |
|----------|----------------|------------------------|--------|
| Modelado de flujos | DAG Workflow | Pipelines lineales | Permite ramificación y paralelismo |
| Paso de datos | Artifact Passing (S3) | Paso por memoria/RPC | Persistencia y tolerancia a fallos |
| Coordinación | Orquestación (Argo) | Coreografía | Visibilidad y control centralizado |
| Persistencia | Object Storage | Base de datos | Datos no estructurados, grandes volúmenes |
